# 1.Установка LIMB
## 1.1. Установка, общие сведения
LIMB - это минифреймворк для простых веб приложений;
LIMB предоставляет следующие возможности:
- Создание, редактирование и удаление таблиц. Все происходит исключительно через веб-интерфейс.
- Автоматическое создание классов для работы с созданными таблицами и данными.
- Автоматическое заполнение таблиц, при условии их создания через компоненты предоставляемые Limb, простая настройка процесса заполнения (email, image, ЧПУ ссылки, пароли).
- Модули пагинации, авторизации/регистрации, оформление: Bootstrap 5
- Собственный шаблонизатор с возможностью контроля доступа {Работает вместе с модулем аторизации и регистрации}
- Взаимодействие с вашим ботом Telegram
## 1.2. Установка и настройка
1. Скачать на сервер папку с Limb;
2. Переименовать ее в название вашего будущего проекта;
3. Создать базу данных (Mysqli);
4. Изменить настройки подключения к вашей БД: limb/app/base/db.ini
```
host='localhost';
name_db='название_вашей_бд';
user='root';
password='';
fornameDB='3289t_';
nameForm='connect';
```
5. Если вы сейчас перейдете по адресу вашего сайта, то попадете на демонстрационную страницу лимба. Здесь будет ваш сайт. Чтобы перевести Limb в режим работы с таблицами необходимо поменять route. Располагается в limb/app/web/route.php.
```
$this -> routeLimb();#Limb работа с таблицами
// $this -> routePublicLimb(); #ваш проект
```
Чтобы изменить направление перехода, достаточно закомментировать routeLimb() и раскомментировать routePublicLimb()
# 2. Работа с таблицами MYSQLI
## 2.1. Способ 1. Создание таблиц через шаблоны
Один из способов - использование шаблонов, хорош когда у вас есть наработанные шаблоны, либо предложенные вам подходят, если нет, то можно прочитать следующий абзац про создание своих шаблонов.
### 2.1.1 Создание своего шаблона
Шаблоны располагаются в каталоге datastore/template/..., все в формате ini, при создании используются принятые на LIMB сокращения.
```
table_name = 'user';
id = 'this_id';
name = 'VARCHAR(250)';
login = 'VARCHAR(60)';
email = 'VARCHAR(255)';
password = 'VARCHAR(32)';
status = 'VARCHAR(50)';
date_creation = 'this_date';
```
Если у вас есть нужный шалблон, то переходим в меню "Шаблоны" и ищем нужный шаблон таблицы.
При создании таблицы шаблон можно будет подредактировать.
Переходим по ссылке на нужный шаблон и если нужно, то редактируем, руководствуясь следующим параграфом этой части, либо - если все устраивает - создаем таблицу.
**Важно! При создании таблицы рекомендуется писать нормальное имя. Например: таблица пользователей users, для безопасности перед названием таблицы будет добавлена приставка, которую вы ранее уже задали в "настройках". Использовать лучше простые имена, потому как при создании таблицы будет создано еще и два класса с использованием ее имени, соотвественно без использования приставки.**
## 2.2. Способ 2. Создание таблиц вручную, через главное меню
Вручную - это все таже структура ini файла. Первой строчкой которого всегда идет, где standart - имя создаваемой таблицы:
```
table_name = "standart";
```
Далее - вариативно, в зависимости от ваших нужд:
```
... = int(num);
... = float(num);
... = double(num);
... = boolean;
... = char;
... = varchar(num);
... = text;
```
## 2.3. Импорт, не рекомендуется
С этим способом все просто, но большинство возможностей будет потеряно. Например такие важные, как автозаполнение таблиц.
Для реализации достаточно ранее откуда-то экспортированную базу данных из файла mydb.sql (например), вставить кодом в текстовое поле в параграфе "импорт".
## 2.4. Заполнение рыбой текстом таблиц БД
Расположение: app/base/control/Generate.php
Для стандартного заполнения таблиц текстом-рыбой воспользуйтесь блоком на странице созданной таблицы: просто введите количество желаемых записей в таблице и отправьте.
При создании таблицы средствами limb в автоматическом режиме создаются две таблицы в code/site. Первая, входная - это name_tablePage.php, вторая, для взаимодействия с базой данных - name_tableTable.php.
Если у вас идет ячейка NULL, то в запросе уберите вокруг этой переменной прямые одинарные кавычки. Обычно это происходит при необходимости записать id, которое автоматом инкрементируется. Это можно сделать в файле: code/site/name_tableTable.php, там же находится и тонкая настройка заполнения таблиц. А именно в методе insertFieldLimb($num), который принимает $num - как количество генерируемых записей, и ничего, кроме хорошего настроения не возвращает.
Тонкая настройка заключается прежде всего в настройке методов из класса Generate.
Использование:
```
use app/ base/ control as Control;
$n = Control/ Generate::this_idgenerate();
```
`this_idgenerate()` - генерирует id, вызывается по умолчанию, возвращает NULL

`this_dategenerate()` - вызывается по умолчанию, возвращает NULL

`intgenerate($num = 0)` - Генерирует число int, либо с произвольным количеством десятков, либо с заданным $num

`varchargenerate($num)` - Генерирует строку на кириллице, с заданным количеством символов

`textgenerate($num = "no")` - Генерирует string на кириллице, заданной длинной либо произвольной от 200 до 900 символов

`floatgenerate()` - Генерирует число float, формата: x.xxxx;

`booleangenerate()` - Генерирует boolean, условно это int [0, 1];

`imagegenerate()` - Генерирует строку с названием действительного изображения: "limb.jpg"

`linkgenerate($name)` - Генерирует число ссылку либо иное. Переводит выражение из кириллицы на латиницу

`passgenerate()` - Генерирует пароль из пяти 1, 2, 3, 4. И возвращает их md5("11111")

`codegenerate($num)` - Генерирует код длинной в $num, в генерации также учавствуют следующие символы: !@%^&*

`nameLatinGenerate($num)` -Генерирует код длинной в $num, в генерации НЕ учавствуют следующие символы: !@%^&*, только большие и маленькие латинские буквы.
# 3. Добавление пагинации
1. В страницу *.tm на которой необходима пагинация разместить: %module_paginate%
2. В конце формирования запроса в таблицу на то, что необходимо разделить на страницы добавить метод
```
$result = $si -> paginateQ(5);# где 5 - количество записей выводимых на одной 
```
Функция paginateQ(..) возвращает массив, где [0] - это нужная нам таблица из базы данных в нужном количестве, а [1] - это непосредственно собранный для данной страницы модуль пагинации
3.	Выполнить замену %module_paginate % на второй элемент полученного массива с данными, вместе со всей остальной заменой. module_paginate работает с bootstrap 5.
# 4. Авторизация и регистрация
# 4.1. Добавление авторизации и регистрации на сайт
Стандартная авторизация с регистрацией представляет собой пару страниц (страница авторизации: /auth, страница регистрации: /registration, и страница восстановления пароля: /auth/newpassword) и набор кода, сопровождающего страницы. Восстановление пароля происходит через email.
Для того, чтобы появились следующие пути их необходимо прописать в ваш route.php routePublicLimb():
```
#модуль регистрации
elseif($route_arr[0] == "destructauth")
{
	setcookie("code", '', -1);
	setcookie("email", '', -1);
	header("Location:/");				
}
elseif($route_arr[0] == "registration")
{
	$html = new ModulesAuthAuthPage(false);
	$html -> Registration();				
}
elseif($route_arr[0] == "auth")
{
	if(isset($route_arr[1])){
		if($route_arr[1] == "newpassword"){
			$html = new Modules/Auth/AuthPage(false);
			$html -> NewPassword();	
		}
		else
		{
			$html = new Modules/Auth/AuthPage(false);
			$html -> Auth();					
		}
	}
	else
	{
		$html = new Modules/Auth/AuthPage(false);
		$html -> Auth();					
	}	
}
#модуль регистрации
```
После этого станут доступны оба адреса: /auth и /registration. При необходимости отключить один из них по той или иной причине не составляет труда просто удалив их, либо ограничив зарегистрированными пользователями.
Авторизация хранится в cookies в течении дня, если не отмечена галочка "запомнить". В таком случае будет храниться в cookies в течении месяца.
При записи создается пара значений в cookie - email и code, где code - это произвольно генерируемое значение для каждого пользователя - в сессии хранится закешировано в md5, а email - это email пользователя. При совпадении пользователь считается авторизированным.
Важным элементом авторизации является таблица пользователей. Кроме нижеприведенного кода, она также представлена и в шаблонах: user. В случае Limb она должна выглядеть так:
```
table_name = 'user';
id = 'this_id';
name = 'varchar(100)';
email = 'varchar(100)';
password = 'varchar(32)';
access_user = 'varchar(50)';
code_email = 'varchar(50)';
code = 'varchar(100)';
date = 'this_date';
```
# 4.2. Проверка авторизации пользователя, защита route
Основной принцип ограничение чего-либо по принципу авторизованности: - узнать авторизацию поьзователя и(или) статус его авторизации; - внести ограничения через if, либо через других операторов. Есть две важных функции, которые помогут ограничить маршруты.
1. Проверить получить права пользователя: Control::IsRules(); user - обычный пользователь, admin - администратор
2. Проверить авторизацию пользователя на странице: Control::IsAuth(); true - авторизирован, false - не авторизирован
По умолчанию в Limb не удалены элементы проверки на route. Им в классе Route является переменная private $auth. В которую происходит запись через функцию: $this -> auth = ControlControl::IsRules(). Если пользователь авторизирован, то в переменной содержится его статус - user, admin. Если нет - то false
**Ограничение маршрутов**
```
#путь только для зарегистрированных пользователей
if($route_arr[0] == "first" && $this -> auth !== false)
{
	$html = new LimbSiteFitrstPage();
}
#путь только для администратора
if($route_arr[0] == "administrator" && $this -> auth == "admin")
{
	$html = new LimbSiteFitrstPage();
}
```
# 4.3. Стандартные роли, создание своих ролей
Под ролями будем понимать отношение пользователя к какому-либо уровню доступа. Например предустановленные: 'admin', 'user', 'noauth', 'all'. Admin - открывает доступность для администратора, user - для зарегистрированного пользователя (присваивается при регистрации, изменить можно вручную, либо написав интерфейс для изменения этого параметра в таблице user), noauth - доступно для незарегистрированных пользователей, all - для всех пользователей.
Для того, чтобы добавить свои роли достаточно записать их в поле класса AuthAccess после, перечисленных стандартом в массиве $roles:
```
private $roles = ['admin', 'user', 'noauth', 'all'];
```
Класс AuthAccess необходим для работы шаблонизатора в части отсеивания той html части, которую должны видеть лишь определенные круги пользователей.
Возможное содержание файла .tm:
```
%startuser% 
	Видит любой зарегистрированный пользователь
%enduser%

%startadmin%
	Видит только владелец сайта, администратор
%endadmin%

%startnoauth%
  Код видимый лишь неавторизированным пользователям, скрывается при положительной
  авторизации пользователя
%endnoauth%

%startall%
  Какой-то код, видимый исключительно зарегистрированным пользователям [user и admin]
%endall%

...Какой-то код который видят все
```
Все типы ролей со знаком процента указывать без пробела. Для замены в шаблоне специальных имен необходимо создать класс AuthAccess и воспользоваться методом getResult() (конечно если это необходимо отдельно, ведь это уже включено в функцию вывода каждой страницы Limb, если подключен модуль AUTH, либо самостоятельного созданного и основанного на методе TemplateMaster(), объекта Limb из AppWorker).
# 5. Работа с html формой
# 5.1. Создание формы html и работа с ней
Форма создается следующим кодом:
```
<form name="auth" action="/app/form/FormRoute.php" method="post">
	%csrf%
	#ваш код
	<button type="submit" class="btn btn-success mt-2" id="submit" name="nameForm" value="auth">Войти</button>
</form>
```
В создании формы важно три момента:
Во-первых она должна уходить по указанному адресу: /app/form/FormRoute.php. Во-вторых, submit должен быть такой формы, где у него четко определен name, как "nameForm", и любой удобный идентификатор - value, который затем должен быть обозначен в FormRoute - (fr), и в-третьих - form должна иметь скрытое поле со значением для проверки на стороне сервера. Это достигается элементом шаблона %csrf%, который после прохода шаблонизатора будет заменен на реальное поле.
Организация csrf в файле php, в котором вы собираете данную страницу выглядит так:
```
$csrf = Form/FormBase::csrf();
```
Путь массива $_POST, после попадания в fr:
Создается родительский объект FormBase с одновременной записью экранированных элементов массива $_POST в поле массив $data. В FormRoute массив находится недолго. Он сразу же отправляется в родительский FormBase, а затем и вообще на вольные просторы ранее написанных классов.
Чтобы поле избежало экранирования ф-ей htmlspecialchars необходимо его внести в исключение $ex, класса formBase.
# 5.2. Создание формы html для загрузки файлов и работа с ней
Для загрузки изображений html форма обычно приобретает у себя: enctype="multipart/form-data".
За загрузку изображений ответственен класс FormFile()
Все также важно три момента:
Во-первых она должна уходить по указанному адресу: /app/form/FormRoute.php. Во-вторых, submit должен быть такой формы, где у него четко определен name, как "nameForm", и любой удобный идентификатор - value, который затем должен быть обозначен в FormRoute - (fr).
Кроме них добавился и четвертый: если изображений больше одного одновременно, то их имена должны указываться с нумерацией: file1, file2, file3...
Путь сохранения, контролируемый размер и расширение настраивается в файле setting.ini в корне сайта.
```
[file load]
max_size_file = '5242880';
ex_file = 'png, jpg, jpeg, bmp, svg';
folder_file = 'resourse/visible/content/';
```
# 6. Запросы к базе данных
Для работы с этим классом также необходимо создание его экземпляра. Правильный вариант работы с ним:
```
$si = new BaseSearchInq("table_name");
$si -> selectQ();
$si -> whereQ("link", $link, "=");
$result = $si -> resQ(); 
```
В этом коде мы создали объект содержащий таблицу, далее начали строить SQL запрос, то есть selectQ нам дало: SELECT * FROM `table_name`, whereQ - прибавило к тому что есть WHERE 'link' = $link, а последним запросом resQ мы выполнили запрос в бд и получили ответ в форме: [ 0 => [id = 'de', 'name' = 'dde'], 1 => [... ] ]
`selectQ()` - Создает новый запрос и выражение "SELECT *FROM `table`"

`whereQ($key, $value, $operator)` - Продолжает запрос от selectQ(): "WHERE $key = 'value'"

`orderDescQ($fields = "")` - Продолжает запрос от selectQ() создавая правило сортировки. Если не задан ни один элемент в аргумент метода, то сортировка происходит по id: ORDER BY `id` DESC"

`orderAscQ($fields = "")` - Продолжает запрос от selectQ() создавая правило сортировки. Если не задан ни один элемент в аргумент метода, то сортировка происходит по id: ORDER BY `id` ASC"

`limitQ($start, $length)` - добавляет в ранее созданный query - "LIMIT strart, length"

`resQ()` - возвращает в результате таблицу найденного, также пишет ее в поля класса. Возврат происходит в виде массива: [ 0 => [id = 'de', 'name' = 'dde'], 1 => [... ] ]

`paginateQ($num)` - Метод возвращает массив с двумя элементами, 0 - таблица результатов количеством, равным $num, а 1 - html элемент пагинации для вставки/замены на страницу.

# 6.1. Класс SearchInq
Для работы с этим классом также необходимо создание его экземпляра. Правильный вариант работы с ним:
```
$si = new BaseSearchInq("table_name");
$si -> selectQ();
$si -> whereQ("link", $link, "=");
$result = $si -> resQ(); 
```
В этом коде мы создали объект содержащий таблицу, далее начали строить SQL запрос, то есть selectQ нам дало: SELECT * FROM `table_name`, whereQ - прибавило к тому что есть WHERE 'link' = $link, а последним запросом resQ мы выполнили запрос в бд и получили ответ в форме: [ 0 => [id = 'de', 'name' = 'dde'], 1 => [... ] ]

`selectQ()` - Создает новый запрос и выражение "SELECT *FROM `table`"

`whereQ($key, $value, $operator)` - Продолжает запрос от selectQ(): "WHERE $key = 'value'"

`orderDescQ($fields = "")` - Продолжает запрос от selectQ() создавая правило сортировки. Если не задан ни один элемент в аргумент метода, то сортировка происходит по id: ORDER BY `id` DESC"

`orderAscQ($fields = "")` - Продолжает запрос от selectQ() создавая правило сортировки. Если не задан ни один элемент в аргумент метода,  то сортировка происходит по id: ORDER BY `id` ASC"
 
`limitQ($start, $length)` - добавляет в ранее созданный query - "LIMIT strart, length"

`resQ()` - возвращает в результате таблицу найденного, также пишет ее в поля класса. Возврат происходит в виде массива: [ 0 => [id = 'de', 'name' = 'dde'], 1 => [... ] ]
 
`paginateQ($num)` - Метод возвращает массив с двумя элементами, 0 - таблица результатов количеством, равным $num, а 1 - html элемент пагинации для вставки/замены на страницу.

# 6.2. Класс RedactionInq
Обязательным условием является создание класса. При чем при создании он просит название таблицы и ее key. Как это выглядит, ниже в примере:
```
$name_table = 'article';
$key = "`id`, `name`, `category`, `image`, `date_creation`";
$value = "".$id.", '".$name."', '".$category."', '".$image."',  '".$date_creation."'";
$ri = new BaseRedactionInq($name_table, $key);
$result = $ri -> insert($value);
```
`insert($value)` - Вставляет строку в таблицу, возвращает ее ID, value - набор значений формата: 'значение1', 'значение2'...

`update($key_red, $value_red, $key, $val)` - Обновляет значение столбца $key_red на $value_red, в той строке где столбец $key равен значению $val

`delete($key, $value)` - Удаляет строку, в которой столбец $key равен значению $val

`copy($table_old, $key, $value)` - Копирует строку из текущей таблицы с выборкой $key = $value в таблицу $table_old

# 7. Шаблонизатор
# 7.1. Схема построения .tm
view
Все пользовательские шаблоны хранятся в view/public, где систематизируются по папкам по названию страниц, либо иначе.
Существует две распространенных замены в шаблонизаторе. Первая - повторяющаяся, например статьи на сайте. Вторая - неповторяющаяся, например 'title'. В случае повторяющегося элемента, в котором требуется лишь замена из подготовленного массива, достаточно его в шаблоне выделить следующим образом:
```
^start_repeat_menu^
%name%  %shema_postroeniya_tm%
<a href="/category/% shema_postroeniya_tm %" class="list-group-item list-group-item-action"> %name% </a>
^end_repeat_menu^
```
Внутри ограничений start - end используются стандартные методы обертки заменяемых элементов, то есть: '%'. Важно понимать, что любой повторяющийся компонент на сайте, оформляется, как указано выше. Важно учесть три правила:
1. ^start_repeat_NAME^, где name - произвольное имя для повторяющейся части.
2. Второй строкой ОБЯЗАТЕЛЬНО идет перечисление через пробел требующих замены шаблонов.
3. Имена предпочтительней выбирать в соответствии с названиями в таблице, чтобы упростить процесс замены и настройки передающего массива.
Limb устроен таким образом, что в нем приветсвуется двойная замена. То есть сразу собирается статическая - неизменная для одного пользователя, часть страницы (staticPage.php, staticTable.php). На ее основании идет сборка остальных страниц.
Конструкцию с выражением ^start_repeat_NAME^ можно использовать и непосредственно на самой странице, так и вынеся ее в отдельный сегмент в формате .tm. Для каждой страницы рекомендуется создавать свою папку с "сегментами". Имя файла должно совпадать с заменяемым шаблоном на странице %user_name% -> папка user(любое удобное имя, можно как название страницы) -> user_name.tm (обязательно).
Есть два устойчивых выражения, применение которых зарезервировано % name_site% и % module_paginate%. Единственная разница в том, что paginate необходимо заменять самостоятельно, а name_site подставляется из setting.ini
# 7.2. Сопровождение шаблона в .php
Есть 4 файла:
**layouts/main.tm (основной)**
```
%title% - %name%
%art%
<ul>
^start_repeat_menu^
%st% %folder% `
<li>%folder% %st%</li>
^end_repeat_menu^
</ul>
%dies%
%content%
```

**footer/art.tm (должен пойти на место %art%)**
```
пустая строка
%category% %name_subcategory%
<h1>%category%</h1>
<h3>%name_subcategory%</h3>
^start_repeat_frs^
%name_table%
<p>%name_table%</p>
^end_repeat_frs^
```


**footer/content.tm (должен пойти на место %content%)**
```
^start_repeat_content^
%name% %text% `
<h3>%name%</h3>
<p>%text%</p>
^end_repeat_content^
```

**footer/dies.tm (должен пойти на место %dies%)**
```
пустая строка
%name% %text%
<h3>%name%</h3>
<p>%text%</p>
```

Для сборки страницы main.tm необходимо:

```
$content = [["name" => "vio", ...], [...], ....];#такого же формата массив 
#возвращается после работы с базой данных
$template = [
	"norepeat" => ["%title%", "%name%"],
	"repeat" => ["menu"],
	"internal" => [
                ["name" => "content", "folder" => "footer"], 
                ["name" => "art", "folder" => "footer"], 
                ["name" => "dies", "folder" => "footer"]
         ],
	"repeat_tm" => ["frs"]
];
$data = [
        "norepeat" => ["title" => "Главная страница", "name" => "Перечень"],
        "internal" => [$content, $art, $dies],
        "repeat_tm" => [$frs]
];
$limb = new WorkerLimb();
$render = $limb -> TemplateMaster($template, $data, $auth, $this -> html);
return $render;
```

# 8. Использование стилей(сss) и скриптов(js)
**Подключение существующих стилей**
Предположим, что у вас уже есть готовые файлы расширений js и css, которые должны подключаться либо вверх html страницы, либо вниз. Ваши файлы стилей конечно хранятся там, где это преусмотрено, то есть в style/public/css(js). Для того чтобы их подключить необходимо:
1) В теге head, а также внизу страницы(в необходимом месте) вставить два "шаблонособирателя": %script_top% и %script_bottom%
2) Прописать правила замены в файл view/public/include_style.ini:
```
;article page
article_top = "bootstraptop&jquerytop&clicks_button.js&dtbs.css";
article_bottom = "";
```
Где article_.... это название собираемой страницы из route. Главная страница имеет всегда название main. В файле к каждой странице должно быть прописано и top и bottom, даже если один из них пуст.
bootstraptop, jquerytop - это названия подключаемых файлов из папки datastore/include_style/.... Для создания своего подобного файла, необходимо прописать в нем необходимое подключение, например шрифты и сохранить с любым именем, но расширением .tm в указанный каталог. При подключении обращаться к нему без расширения, как в примере выше.

# 9. Использование JSON и AJAX
**Расположение важных файлов**
Все файлы, которые помогают использовать json располагаются в app/modules/aj. К таким файлам относится класс Jon, файл которого, jon.php самолично обрабатывает запросы приходящие от браузера методом post.
**Принцип работы**
Файл, который отправляет запрос выглядит примерно так:
```
$(document).on("click", ".view_answ", function(event){
event.preventDefault();
var idElement = event.target.id;
var id_html = "#two_"+idElement;
$.ajax({
    url: '/app/modules/aj/Jon.php',
    method: 'POST',
    data: {"id" : idElement, "nameAj" : "loadCommentary"},
    }).done(function(data){
        $(id_html).html(data);
    });
});
```
При наличии в массиве $_POST переменной под nameAj, а также наличии уже созданного метода в классе Jon с именем, в данном случае loadCommentary создается объект класса Jon. Весь пришедший массив $_POST записывается в переменную $post_nohtml с предобработкой функцией htmlspecialchars. Исключения для прохождения через htmlspecialchars составляют лишь имена массива $_post ключи к которым перечисленны в массиве $ex.
# 10. Мультиязычность
Обеспечение мультиязычности в текущей версии LIMB обеспечивается множеством нюансов. Поочереди:
**route.php**
При любом входе в веб-приложение создается COOKIE переменная language содержащая информацию о языке в виде: ru_.
```
if(!isset($_COOKIE["language"]))
setcookie("language", "ru_", time() + 172800, '/');
```
Далее идет маршрут позволяющий переключать языки, простой перезаписью переменной в сессии. Это организовано таким образом, что берется массив заранее определенный в setting.ini. То есть маршруты: lang/ru_, lang/eng_ являются переключающими на соответствующий язык.
```
elseif($route_arr[0] == "lang")
{
$this -> forms = true;
if(isset($route_arr[1]))
	{
		$ini = parse_ini_file(__DIR__."/../../setting.ini");
		$lang_group = explode(", ", $ini["language"]);
		if($this -> langGroup($lang_group, $route_arr[1]))
		{
              		setcookie("language", $route_arr[1], time() + 172800, '/');
			header("Location: ".$_SERVER["HTTP_REFERER"]);
			exit();
		}
		else
		{
			header("Location: ".$_SERVER["HTTP_REFERER"]);
			exit();
		}
	}
}

```
**ru_page и ru_public**
Второй предустановленный нюанс это текхнология размещения и названия папок с шаблонами различных языков. То есть каждый язык, предопределенный в setting.ini должен иметь: view/ru_page.ini, view/ru_public. Если из языков предусмотрен лишь русский, то все шаблоны располагаются в папке ru_public. Вообще добавление второго, третьего языка лучше осуществлять лишь, после собрания сайта полностью работающего на одном языке, путем копирования, перевода и переименования основного рабочего public. Естественно собирать сайт на одну папку public необходимо учитывая следующие рекомендации.
**StaticPage.php&StaticTable.php**
Следуя принципу разделения сборки сайта на две части: статической(неизменной) части и изменяющейся, предполагаю расположение языковой панели именно в сборке этих файлов.
```
if(isset($_COOKIE['language'])) $this -> language = $_COOKIE['language'];
else 
{
	$this -> language = "ru_";
}
#вверху конструктора, объявление переменной $this-> language, 
#для дальнейшего использования в путях(это касается всех файлов), 
#ниже касающееся исключительно staticpage. 
#здесь берется массив возможных языков из setting.ini
#и сравнивается с текущим установленным языком в cookies
#тот язык который установлен в свой шаблон получает новый стиль,
#для удобства видимости 
$language_group = $this -> setting["language"];
$language_group = explode(",", $language_group);

for($i = 0; $i < count($language_group); $i++)
{
	if(trim($language_group[$i]) == $this -> language)
		$language_group[$i] = "style='border-bottom: 1px solid #fff;'";

	else
		$language_group[$i] = "";
}
```
Массив, записанный строкой в setting.ini должен иметь ту же очередность, что и массив записанный в tpage под замену шаблона: "%site%", "%lang_ru%", "%lang_eng%". Именно такого рода рекомендуется располагать в конечном виде в языковой панели. Языковая панель подключается в .tm
**main.tm**
```
<a class="lang " href="https://limb.website/lang/ru_" %lang_ru%="">RU</a>|
<a class="lang " href="https://limb.website/lang/eng_" %="" lang_eng="">ENG</a>
```
**file_get_contents() и пр.**
Все пути, должны содержать перед public вставку, корректирующие используемый язык
```
$html = file_get_contents(__DIR__."/../../view/".$this -> language."public/main.tm");
```
# 11. Добавление комментариев к странице
Модуль состоит из: app/modules/commentary{CommentaryTable.php CommentaryPage.php}. Файлов шаблона public/commentary. И js-обеспечение, двумя файлами: ajax_commentary.js clicks_button.js.
Для добавления комментариев необходимо создать таблицу:
```
table_name = '39t_commentary';
id = 'this_id';
id_article = 'int(11)';
name = 'varchar(100)';
text = 'text';
levels = 'text';
nesting = 'int(11)';
code = 'text';
date_creation = 'this_date';
```
Где levels - это code комментария к которому относится данный комментарий, nesting - текущая вложенность данного комментария, code - уникальный ключ комментария, id_article - id статьи к которой комментарий относится.
**Маршруты в route.php**
Для будущей организации админ-панельки под редактирование, удаление комментариев для auth = admin.
**Form/FormRoute.php FormBase.php**
```
#FormRoute
elseif($name_form == "commentarynew")
{
	$result = $this -> newCommentary();
}

#FormBase
protected function newCommentary()
{
	$ar = CommCommentaryTable::addCommentary($this -> data);
	return $ar;
}
#реализация добавления комментария
```
**a/Jon.php**
```
public function loadCommentary()
{
	$ct = new ComCommentaryTable();

	$result = $ct -> LoadCommentary($this -> post_nohtml["id"]);

	echo $result;
}
#для дозагрузки комментариев по клику без обновления страницы
```
**Подключение**
В нужной части страницы (элемента страницы .tm) необходимо прописать %commentary% и произвести замену на:
```
$com = new CommentaryTable();
$commentary = $com -> renderCommentary($id, $auth);
```
Где $id - id статьи, под которую выводятся комментарии, а $auth - идентификатор авторизации.
Настройка отображения комментариев через setting.ini. nesting - максимальная вложенность комментариев, по умолчанию 2, comm_paginate - количество одновременно выводимых комментариев на странице.

# 12. Телеграм бот
