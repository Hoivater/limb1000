# 1.Установка LIMB
## 1.1. Установка, общие сведения
LIMB - это минифреймворк для простых веб приложений;
LIMB предоставляет следующие возможности:
- Создание, редактирование и удаление таблиц. Все происходит исключительно через веб-интерфейс.
- Автоматическое создание классов для работы с созданными таблицами и данными.
- Автоматическое заполнение таблиц, при условии их создания через компоненты предоставляемые Limb, простая настройка процесса заполнения (email, image, ЧПУ ссылки, пароли).
- Модули пагинации, авторизации/регистрации, оформление: Bootstrap 5
- Собственный шаблонизатор с возможностью контроля доступа {Работает вместе с модулем аторизации и регистрации}
- Взаимодействие с вашим ботом Telegram
## 1.2. Установка и настройка
1. Скачать на сервер папку с Limb;
2. Переименовать ее в название вашего будущего проекта;
3. Создать базу данных (Mysqli);
4. Изменить настройки подключения к вашей БД: limb/app/base/db.ini
```
host='localhost';
name_db='название_вашей_бд';
user='root';
password='';
fornameDB='3289t_';
nameForm='connect';
```
5. Если вы сейчас перейдете по адресу вашего сайта, то попадете на демонстрационную страницу лимба. Здесь будет ваш сайт. Чтобы перевести Limb в режим работы с таблицами необходимо поменять route. Располагается в limb/app/web/route.php.
```
$this -> routeLimb();#Limb работа с таблицами
// $this -> routePublicLimb(); #ваш проект
```
Чтобы изменить направление перехода, достаточно закомментировать routeLimb() и раскомментировать routePublicLimb()
# 2. Работа с таблицами MYSQLI
## 2.1. Способ 1. Создание таблиц через шаблоны
Один из способов - использование шаблонов, хорош когда у вас есть наработанные шаблоны, либо предложенные вам подходят, если нет, то можно прочитать следующий абзац про создание своих шаблонов.
### 2.1.1 Создание своего шаблона
Шаблоны располагаются в каталоге datastore/template/..., все в формате ini, при создании используются принятые на LIMB сокращения.
```
table_name = 'user';
id = 'this_id';
name = 'VARCHAR(250)';
login = 'VARCHAR(60)';
email = 'VARCHAR(255)';
password = 'VARCHAR(32)';
status = 'VARCHAR(50)';
date_creation = 'this_date';
```
Если у вас есть нужный шалблон, то переходим в меню "Шаблоны" и ищем нужный шаблон таблицы.
При создании таблицы шаблон можно будет подредактировать.
Переходим по ссылке на нужный шаблон и если нужно, то редактируем, руководствуясь следующим параграфом этой части, либо - если все устраивает - создаем таблицу.
**Важно! При создании таблицы рекомендуется писать нормальное имя. Например: таблица пользователей users, для безопасности перед названием таблицы будет добавлена приставка, которую вы ранее уже задали в "настройках". Использовать лучше простые имена, потому как при создании таблицы будет создано еще и два класса с использованием ее имени, соотвественно без использования приставки.**
## 2.2. Способ 2. Создание таблиц вручную, через главное меню
Вручную - это все таже структура ini файла. Первой строчкой которого всегда идет, где standart - имя создаваемой таблицы:
```
table_name = "standart";
```
Далее - вариативно, в зависимости от ваших нужд:
```
... = int(num);
... = float(num);
... = double(num);
... = boolean;
... = char;
... = varchar(num);
... = text;
```
## 2.3. Импорт, не рекомендуется
С этим способом все просто, но большинство возможностей будет потеряно. Например такие важные, как автозаполнение таблиц.
Для реализации достаточно ранее откуда-то экспортированную базу данных из файла mydb.sql (например), вставить кодом в текстовое поле в параграфе "импорт".
## 2.4. Заполнение рыбой текстом таблиц БД
Расположение: app/base/control/Generate.php
Для стандартного заполнения таблиц текстом-рыбой воспользуйтесь блоком на странице созданной таблицы: просто введите количество желаемых записей в таблице и отправьте.
При создании таблицы средствами limb в автоматическом режиме создаются две таблицы в code/site. Первая, входная - это name_tablePage.php, вторая, для взаимодействия с базой данных - name_tableTable.php.
Если у вас идет ячейка NULL, то в запросе уберите вокруг этой переменной прямые одинарные кавычки. Обычно это происходит при необходимости записать id, которое автоматом инкрементируется. Это можно сделать в файле: code/site/name_tableTable.php, там же находится и тонкая настройка заполнения таблиц. А именно в методе insertFieldLimb($num), который принимает $num - как количество генерируемых записей, и ничего, кроме хорошего настроения не возвращает.
Тонкая настройка заключается прежде всего в настройке методов из класса Generate.
Использование:
```
use app/ base/ control as Control;
$n = Control/ Generate::this_idgenerate();
```
`this_idgenerate()` - генерирует id, вызывается по умолчанию, возвращает NULL

`this_dategenerate()` - вызывается по умолчанию, возвращает NULL

`intgenerate($num = 0)` - Генерирует число int, либо с произвольным количеством десятков, либо с заданным $num

`varchargenerate($num)` - Генерирует строку на кириллице, с заданным количеством символов

`textgenerate($num = "no")` - Генерирует string на кириллице, заданной длинной либо произвольной от 200 до 900 символов

`floatgenerate()` - Генерирует число float, формата: x.xxxx;

`booleangenerate()` - Генерирует boolean, условно это int [0, 1];

`imagegenerate()` - Генерирует строку с названием действительного изображения: "limb.jpg"

`linkgenerate($name)` - Генерирует число ссылку либо иное. Переводит выражение из кириллицы на латиницу

`passgenerate()` - Генерирует пароль из пяти 1, 2, 3, 4. И возвращает их md5("11111")

`codegenerate($num)` - Генерирует код длинной в $num, в генерации также учавствуют следующие символы: !@%^&*

`nameLatinGenerate($num)` -Генерирует код длинной в $num, в генерации НЕ учавствуют следующие символы: !@%^&*, только большие и маленькие латинские буквы.
# 3. Добавление пагинации
1. В страницу *.tm на которой необходима пагинация разместить: %module_paginate%
2. В конце формирования запроса в таблицу на то, что необходимо разделить на страницы добавить метод
```
$result = $si -> paginateQ(5);# где 5 - количество записей выводимых на одной 
```
Функция paginateQ(..) возвращает массив, где [0] - это нужная нам таблица из базы данных в нужном количестве, а [1] - это непосредственно собранный для данной страницы модуль пагинации
3.	Выполнить замену %module_paginate % на второй элемент полученного массива с данными, вместе со всей остальной заменой. module_paginate работает с bootstrap 5.
# 4. Авторизация и регистрация
# 4.1. Добавление авторизации и регистрации на сайт
Стандартная авторизация с регистрацией представляет собой пару страниц (страница авторизации: /auth, страница регистрации: /registration, и страница восстановления пароля: /auth/newpassword) и набор кода, сопровождающего страницы. Восстановление пароля происходит через email.
Для того, чтобы появились следующие пути их необходимо прописать в ваш route.php routePublicLimb():
```
#модуль регистрации
elseif($route_arr[0] == "destructauth")
{
	setcookie("code", '', -1);
	setcookie("email", '', -1);
	header("Location:/");				
}
elseif($route_arr[0] == "registration")
{
	$html = new ModulesAuthAuthPage(false);
	$html -> Registration();				
}
elseif($route_arr[0] == "auth")
{
	if(isset($route_arr[1])){
		if($route_arr[1] == "newpassword"){
			$html = new Modules/Auth/AuthPage(false);
			$html -> NewPassword();	
		}
		else
		{
			$html = new Modules/Auth/AuthPage(false);
			$html -> Auth();					
		}
	}
	else
	{
		$html = new Modules/Auth/AuthPage(false);
		$html -> Auth();					
	}	
}
#модуль регистрации
```
После этого станут доступны оба адреса: /auth и /registration. При необходимости отключить один из них по той или иной причине не составляет труда просто удалив их, либо ограничив зарегистрированными пользователями.
Авторизация хранится в cookies в течении дня, если не отмечена галочка "запомнить". В таком случае будет храниться в cookies в течении месяца.
При записи создается пара значений в cookie - email и code, где code - это произвольно генерируемое значение для каждого пользователя - в сессии хранится закешировано в md5, а email - это email пользователя. При совпадении пользователь считается авторизированным.
Важным элементом авторизации является таблица пользователей. Кроме нижеприведенного кода, она также представлена и в шаблонах: user. В случае Limb она должна выглядеть так:
```
table_name = 'user';
id = 'this_id';
name = 'varchar(100)';
email = 'varchar(100)';
password = 'varchar(32)';
access_user = 'varchar(50)';
code_email = 'varchar(50)';
code = 'varchar(100)';
date = 'this_date';
```
# 4.2. Проверка авторизации пользователя, защита route
Основной принцип ограничение чего-либо по принципу авторизованности: - узнать авторизацию поьзователя и(или) статус его авторизации; - внести ограничения через if, либо через других операторов. Есть две важных функции, которые помогут ограничить маршруты.
1. Проверить получить права пользователя: Control::IsRules(); user - обычный пользователь, admin - администратор
2. Проверить авторизацию пользователя на странице: Control::IsAuth(); true - авторизирован, false - не авторизирован
По умолчанию в Limb не удалены элементы проверки на route. Им в классе Route является переменная private $auth. В которую происходит запись через функцию: $this -> auth = ControlControl::IsRules(). Если пользователь авторизирован, то в переменной содержится его статус - user, admin. Если нет - то false
**Ограничение маршрутов**
```
#путь только для зарегистрированных пользователей
if($route_arr[0] == "first" && $this -> auth !== false)
{
	$html = new LimbSiteFitrstPage();
}
#путь только для администратора
if($route_arr[0] == "administrator" && $this -> auth == "admin")
{
	$html = new LimbSiteFitrstPage();
}
```
# 4.3. Стандартные роли, создание своих ролей
Под ролями будем понимать отношение пользователя к какому-либо уровню доступа. Например предустановленные: 'admin', 'user', 'noauth', 'all'. Admin - открывает доступность для администратора, user - для зарегистрированного пользователя (присваивается при регистрации, изменить можно вручную, либо написав интерфейс для изменения этого параметра в таблице user), noauth - доступно для незарегистрированных пользователей, all - для всех пользователей.
Для того, чтобы добавить свои роли достаточно записать их в поле класса AuthAccess после, перечисленных стандартом в массиве $roles:
```
private $roles = ['admin', 'user', 'noauth', 'all'];
```
Класс AuthAccess необходим для работы шаблонизатора в части отсеивания той html части, которую должны видеть лишь определенные круги пользователей.
Возможное содержание файла .tm:
```
%startuser% 
	Видит любой зарегистрированный пользователь
%enduser%

%startadmin%
	Видит только владелец сайта, администратор
%endadmin%

%startnoauth%
  Код видимый лишь неавторизированным пользователям, скрывается при положительной
  авторизации пользователя
%endnoauth%

%startall%
  Какой-то код, видимый исключительно зарегистрированным пользователям [user и admin]
%endall%

...Какой-то код который видят все
```
Все типы ролей со знаком процента указывать без пробела. Для замены в шаблоне специальных имен необходимо создать класс AuthAccess и воспользоваться методом getResult() (конечно если это необходимо отдельно, ведь это уже включено в функцию вывода каждой страницы Limb, если подключен модуль AUTH, либо самостоятельного созданного и основанного на методе TemplateMaster(), объекта Limb из AppWorker).
# 5. Работа с html формой
# 5.1. Создание формы html и работа с ней
Форма создается следующим кодом:
```
<form name="auth" action="/app/form/FormRoute.php" method="post">
	%csrf%
	#ваш код
	<button type="submit" class="btn btn-success mt-2" id="submit" name="nameForm" value="auth">Войти</button>
</form>
```
В создании формы важно три момента:
Во-первых она должна уходить по указанному адресу: /app/form/FormRoute.php. Во-вторых, submit должен быть такой формы, где у него четко определен name, как "nameForm", и любой удобный идентификатор - value, который затем должен быть обозначен в FormRoute - (fr), и в-третьих - form должна иметь скрытое поле со значением для проверки на стороне сервера. Это достигается элементом шаблона %csrf%, который после прохода шаблонизатора будет заменен на реальное поле.
Организация csrf в файле php, в котором вы собираете данную страницу выглядит так:
```
$csrf = Form/FormBase::csrf();
```
Путь массива $_POST, после попадания в fr:
Создается родительский объект FormBase с одновременной записью экранированных элементов массива $_POST в поле массив $data. В FormRoute массив находится недолго. Он сразу же отправляется в родительский FormBase, а затем и вообще на вольные просторы ранее написанных классов.
Чтобы поле избежало экранирования ф-ей htmlspecialchars необходимо его внести в исключение $ex, класса formBase.
# 5.2. Создание формы html для загрузки файлов и работа с ней
Для загрузки изображений html форма обычно приобретает у себя: enctype="multipart/form-data".
За загрузку изображений ответственен класс FormFile()
Все также важно три момента:
Во-первых она должна уходить по указанному адресу: /app/form/FormRoute.php. Во-вторых, submit должен быть такой формы, где у него четко определен name, как "nameForm", и любой удобный идентификатор - value, который затем должен быть обозначен в FormRoute - (fr).
Кроме них добавился и четвертый: если изображений больше одного одновременно, то их имена должны указываться с нумерацией: file1, file2, file3...
Путь сохранения, контролируемый размер и расширение настраивается в файле setting.ini в корне сайта.
```
[file load]
max_size_file = '5242880';
ex_file = 'png, jpg, jpeg, bmp, svg';
folder_file = 'resourse/visible/content/';
```
# 6. Запросы к базе данных
# 6.1. Класс SearchInq
# 6.2. Класс RedactionInq
# 7. Шаблонизатор
# 7.1. Схема построения .tm
# 7.2. Сопровождение шаблона в .php
# 8. Использование стилей(сss) и скриптов(js)
# 9. Использование JSON и AJAX
# 10. Мультиязычность
# 11. Добавление комментариев к странице
# 12. Телеграм бот
